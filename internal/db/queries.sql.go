// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (
    user_id, name, class, level, race, background, alignment, experience_points,
    strength, dexterity, constitution, intelligence, wisdom, charisma,
    max_hit_points, current_hit_points, temporary_hit_points,
    armor_class, speed,
    saving_throw_proficiencies, skill_proficiencies,
    equipment, features_traits, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14,
    $15, $16, $17,
    $18, $19,
    $20, $21,
    $22, $23, $24
)
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type CreateCharacterParams struct {
	UserID                   pgtype.UUID `json:"user_id"`
	Name                     string      `json:"name"`
	Class                    string      `json:"class"`
	Level                    int32       `json:"level"`
	Race                     string      `json:"race"`
	Background               pgtype.Text `json:"background"`
	Alignment                pgtype.Text `json:"alignment"`
	ExperiencePoints         int32       `json:"experience_points"`
	Strength                 int32       `json:"strength"`
	Dexterity                int32       `json:"dexterity"`
	Constitution             int32       `json:"constitution"`
	Intelligence             int32       `json:"intelligence"`
	Wisdom                   int32       `json:"wisdom"`
	Charisma                 int32       `json:"charisma"`
	MaxHitPoints             int32       `json:"max_hit_points"`
	CurrentHitPoints         int32       `json:"current_hit_points"`
	TemporaryHitPoints       int32       `json:"temporary_hit_points"`
	ArmorClass               int32       `json:"armor_class"`
	Speed                    int32       `json:"speed"`
	SavingThrowProficiencies []string    `json:"saving_throw_proficiencies"`
	SkillProficiencies       []string    `json:"skill_proficiencies"`
	Equipment                []byte      `json:"equipment"`
	FeaturesTraits           string      `json:"features_traits"`
	Notes                    string      `json:"notes"`
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, createCharacter,
		arg.UserID,
		arg.Name,
		arg.Class,
		arg.Level,
		arg.Race,
		arg.Background,
		arg.Alignment,
		arg.ExperiencePoints,
		arg.Strength,
		arg.Dexterity,
		arg.Constitution,
		arg.Intelligence,
		arg.Wisdom,
		arg.Charisma,
		arg.MaxHitPoints,
		arg.CurrentHitPoints,
		arg.TemporaryHitPoints,
		arg.ArmorClass,
		arg.Speed,
		arg.SavingThrowProficiencies,
		arg.SkillProficiencies,
		arg.Equipment,
		arg.FeaturesTraits,
		arg.Notes,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithBoth = `-- name: CreateUserWithBoth :one
INSERT INTO users (email, password_hash, public_key)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, public_key, created_at, updated_at
`

type CreateUserWithBothParams struct {
	Email        pgtype.Text `json:"email"`
	PasswordHash pgtype.Text `json:"password_hash"`
	PublicKey    pgtype.Text `json:"public_key"`
}

func (q *Queries) CreateUserWithBoth(ctx context.Context, arg CreateUserWithBothParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithBoth, arg.Email, arg.PasswordHash, arg.PublicKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithPassword = `-- name: CreateUserWithPassword :one
INSERT INTO users (email, password_hash)
VALUES ($1, $2)
RETURNING id, email, password_hash, public_key, created_at, updated_at
`

type CreateUserWithPasswordParams struct {
	Email        pgtype.Text `json:"email"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) CreateUserWithPassword(ctx context.Context, arg CreateUserWithPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithPassword, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithPublicKey = `-- name: CreateUserWithPublicKey :one
INSERT INTO users (public_key)
VALUES ($1)
RETURNING id, email, password_hash, public_key, created_at, updated_at
`

func (q *Queries) CreateUserWithPublicKey(ctx context.Context, publicKey pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithPublicKey, publicKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters WHERE id = $1
`

func (q *Queries) DeleteCharacter(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCharacter, id)
	return err
}

const deleteCharacterByUserID = `-- name: DeleteCharacterByUserID :exec
DELETE FROM characters WHERE id = $1 AND user_id = $2
`

type DeleteCharacterByUserIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteCharacterByUserID(ctx context.Context, arg DeleteCharacterByUserIDParams) error {
	_, err := q.db.Exec(ctx, deleteCharacterByUserID, arg.ID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getCharacterByID = `-- name: GetCharacterByID :one

SELECT id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at FROM characters WHERE id = $1
`

// Character Queries
func (q *Queries) GetCharacterByID(ctx context.Context, id pgtype.UUID) (Character, error) {
	row := q.db.QueryRow(ctx, getCharacterByID, id)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharactersByUserID = `-- name: GetCharactersByUserID :many
SELECT id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at FROM characters WHERE user_id = $1 ORDER BY updated_at DESC
`

func (q *Queries) GetCharactersByUserID(ctx context.Context, userID pgtype.UUID) ([]Character, error) {
	rows, err := q.db.Query(ctx, getCharactersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Character{}
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Class,
			&i.Level,
			&i.Race,
			&i.Background,
			&i.Alignment,
			&i.ExperiencePoints,
			&i.Strength,
			&i.Dexterity,
			&i.Constitution,
			&i.Intelligence,
			&i.Wisdom,
			&i.Charisma,
			&i.MaxHitPoints,
			&i.CurrentHitPoints,
			&i.TemporaryHitPoints,
			&i.ArmorClass,
			&i.Speed,
			&i.SavingThrowProficiencies,
			&i.SkillProficiencies,
			&i.Equipment,
			&i.FeaturesTraits,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, public_key, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, public_key, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPublicKey = `-- name: GetUserByPublicKey :one
SELECT id, email, password_hash, public_key, created_at, updated_at FROM users WHERE public_key = $1
`

func (q *Queries) GetUserByPublicKey(ctx context.Context, publicKey pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPublicKey, publicKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterAbilities = `-- name: UpdateCharacterAbilities :one
UPDATE characters SET
    strength = $2,
    dexterity = $3,
    constitution = $4,
    intelligence = $5,
    wisdom = $6,
    charisma = $7
WHERE id = $1
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterAbilitiesParams struct {
	ID           pgtype.UUID `json:"id"`
	Strength     int32       `json:"strength"`
	Dexterity    int32       `json:"dexterity"`
	Constitution int32       `json:"constitution"`
	Intelligence int32       `json:"intelligence"`
	Wisdom       int32       `json:"wisdom"`
	Charisma     int32       `json:"charisma"`
}

func (q *Queries) UpdateCharacterAbilities(ctx context.Context, arg UpdateCharacterAbilitiesParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterAbilities,
		arg.ID,
		arg.Strength,
		arg.Dexterity,
		arg.Constitution,
		arg.Intelligence,
		arg.Wisdom,
		arg.Charisma,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterBasicInfo = `-- name: UpdateCharacterBasicInfo :one
UPDATE characters SET
    name = $2,
    class = $3,
    level = $4,
    race = $5,
    background = $6,
    alignment = $7,
    experience_points = $8
WHERE id = $1
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterBasicInfoParams struct {
	ID               pgtype.UUID `json:"id"`
	Name             string      `json:"name"`
	Class            string      `json:"class"`
	Level            int32       `json:"level"`
	Race             string      `json:"race"`
	Background       pgtype.Text `json:"background"`
	Alignment        pgtype.Text `json:"alignment"`
	ExperiencePoints int32       `json:"experience_points"`
}

func (q *Queries) UpdateCharacterBasicInfo(ctx context.Context, arg UpdateCharacterBasicInfoParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterBasicInfo,
		arg.ID,
		arg.Name,
		arg.Class,
		arg.Level,
		arg.Race,
		arg.Background,
		arg.Alignment,
		arg.ExperiencePoints,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterCombat = `-- name: UpdateCharacterCombat :one
UPDATE characters SET
    max_hit_points = $2,
    current_hit_points = $3,
    temporary_hit_points = $4,
    armor_class = $5,
    speed = $6
WHERE id = $1
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterCombatParams struct {
	ID                 pgtype.UUID `json:"id"`
	MaxHitPoints       int32       `json:"max_hit_points"`
	CurrentHitPoints   int32       `json:"current_hit_points"`
	TemporaryHitPoints int32       `json:"temporary_hit_points"`
	ArmorClass         int32       `json:"armor_class"`
	Speed              int32       `json:"speed"`
}

func (q *Queries) UpdateCharacterCombat(ctx context.Context, arg UpdateCharacterCombatParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterCombat,
		arg.ID,
		arg.MaxHitPoints,
		arg.CurrentHitPoints,
		arg.TemporaryHitPoints,
		arg.ArmorClass,
		arg.Speed,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterEquipment = `-- name: UpdateCharacterEquipment :one
UPDATE characters SET equipment = $2 WHERE id = $1 RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterEquipmentParams struct {
	ID        pgtype.UUID `json:"id"`
	Equipment []byte      `json:"equipment"`
}

func (q *Queries) UpdateCharacterEquipment(ctx context.Context, arg UpdateCharacterEquipmentParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterEquipment, arg.ID, arg.Equipment)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterHitPoints = `-- name: UpdateCharacterHitPoints :one
UPDATE characters SET
    current_hit_points = $2,
    temporary_hit_points = $3
WHERE id = $1
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterHitPointsParams struct {
	ID                 pgtype.UUID `json:"id"`
	CurrentHitPoints   int32       `json:"current_hit_points"`
	TemporaryHitPoints int32       `json:"temporary_hit_points"`
}

func (q *Queries) UpdateCharacterHitPoints(ctx context.Context, arg UpdateCharacterHitPointsParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterHitPoints, arg.ID, arg.CurrentHitPoints, arg.TemporaryHitPoints)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterNotes = `-- name: UpdateCharacterNotes :one
UPDATE characters SET
    features_traits = $2,
    notes = $3
WHERE id = $1
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterNotesParams struct {
	ID             pgtype.UUID `json:"id"`
	FeaturesTraits string      `json:"features_traits"`
	Notes          string      `json:"notes"`
}

func (q *Queries) UpdateCharacterNotes(ctx context.Context, arg UpdateCharacterNotesParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterNotes, arg.ID, arg.FeaturesTraits, arg.Notes)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterProficiencies = `-- name: UpdateCharacterProficiencies :one
UPDATE characters SET
    saving_throw_proficiencies = $2,
    skill_proficiencies = $3
WHERE id = $1
RETURNING id, user_id, name, class, level, race, background, alignment, experience_points, strength, dexterity, constitution, intelligence, wisdom, charisma, max_hit_points, current_hit_points, temporary_hit_points, armor_class, speed, saving_throw_proficiencies, skill_proficiencies, equipment, features_traits, notes, created_at, updated_at
`

type UpdateCharacterProficienciesParams struct {
	ID                       pgtype.UUID `json:"id"`
	SavingThrowProficiencies []string    `json:"saving_throw_proficiencies"`
	SkillProficiencies       []string    `json:"skill_proficiencies"`
}

func (q *Queries) UpdateCharacterProficiencies(ctx context.Context, arg UpdateCharacterProficienciesParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateCharacterProficiencies, arg.ID, arg.SavingThrowProficiencies, arg.SkillProficiencies)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Class,
		&i.Level,
		&i.Race,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHitPoints,
		&i.CurrentHitPoints,
		&i.TemporaryHitPoints,
		&i.ArmorClass,
		&i.Speed,
		&i.SavingThrowProficiencies,
		&i.SkillProficiencies,
		&i.Equipment,
		&i.FeaturesTraits,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE users SET email = $2 WHERE id = $1 RETURNING id, email, password_hash, public_key, created_at, updated_at
`

type UpdateUserEmailParams struct {
	ID    pgtype.UUID `json:"id"`
	Email pgtype.Text `json:"email"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.ID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users SET password_hash = $2 WHERE id = $1 RETURNING id, email, password_hash, public_key, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPublicKey = `-- name: UpdateUserPublicKey :one
UPDATE users SET public_key = $2 WHERE id = $1 RETURNING id, email, password_hash, public_key, created_at, updated_at
`

type UpdateUserPublicKeyParams struct {
	ID        pgtype.UUID `json:"id"`
	PublicKey pgtype.Text `json:"public_key"`
}

func (q *Queries) UpdateUserPublicKey(ctx context.Context, arg UpdateUserPublicKeyParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPublicKey, arg.ID, arg.PublicKey)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.PublicKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
